---
layout: post
title: 'Lightweight web-based transactional systems '
date: '2014-12-05T12:08:00.000+02:00'
author: Gerald O'Sullivan
tags:
- JSF
- MVC
- Tomcat 8
- PostgreSQL
modified_time: '2017-07-29T10:20:43.478+02:00'
thumbnail: https://3.bp.blogspot.com/-KVQlzWh47Vg/VIGBz8qc5II/AAAAAAAAAy8/m6SGMBEv9Jc/s72-c/software_doge.png
blogger_id: tag:blogger.com,1999:blog-5063526183496324043.post-1949335172163140076
blogger_orig_url: https://surfacedetail.blogspot.com/2014/12/lightweight-web-based-transactional.html
---

<h3>Reanimating a legacy system</h3><div>I have a set of data from an old legacy application that must be resurrected and web-enabled. The data was extracted from a relational database so it is structured in a conventional third-normal form, but the original application was pensioned off a long time ago, and probably a good thing too.</div><div><br /></div><div>The user interface and its business logic must be rebuilt as a web-based transactional application so that the data can be accessible from a variety of devices, so I had to decide on a technology stack, but how? There are dozens of database systems, hundreds of software languages, scores of web-development frameworks, and more opinions about the matter than there are trolls on 9GAG.</div><div><br /></div><div class="separator" style="clear: both; text-align: center;"></div><div><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-KVQlzWh47Vg/VIGBz8qc5II/AAAAAAAAAy8/m6SGMBEv9Jc/s1600/software_doge.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="243" src="https://3.bp.blogspot.com/-KVQlzWh47Vg/VIGBz8qc5II/AAAAAAAAAy8/m6SGMBEv9Jc/s1600/software_doge.png" width="320" /></a></div><br />The formal approach to making a decision would be to consider all the various technologies at each layer of the application stack and then&nbsp;weigh up the pros and cons of&nbsp;each.</div><div><br /></div><div>A less formal approach would be to ask someone who has done this sort of thing before, like a grizzled Unix veteran or an 31337 h4x0r.&nbsp;</div><div><br /></div><div>In the end I applied a <a href="http://en.wikibooks.org/wiki/Algorithms/Divide_and_Conquer" target="_blank">divide and conquer</a> algorithm to eliminate dozens of decision points in a few strokes.<br /><br /></div><h3>MVC or not?</h3><div>The first thing to decide is the core structure of the application. The application must be web-based, and most dynamic web-sites are based on a Model-View-Controller architecture, but is this pattern still relevant today? Is it applicable to my use case?</div><div><br /></div><div>I have a data set that must be viewed and maintained because of its historical value, so the application must have a Model. It is not a utility program that has no persistent data.&nbsp;</div><div><br /></div><div>It must be a web-based system, accessible from various user interfaces like a browser or smartphone app, so it must have a View. This is not a command-line application.&nbsp;</div><div><br /></div><div>Lastly, the data set will be the subject of various views, some of which will be used to maintain and update the data, so the system must have a Controller to manipulate the Model.<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-eA55rtjhdzg/VH1_W6CWZ1I/AAAAAAAAAyE/Xha28ByRHYs/s1600/500px-MVC-Process.svg.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="320" src="https://2.bp.blogspot.com/-eA55rtjhdzg/VH1_W6CWZ1I/AAAAAAAAAyE/Xha28ByRHYs/s1600/500px-MVC-Process.svg.png" width="290" /></a></div><br /><div>So the <a href="http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC pattern</a> is most the logical structure for a web-based&nbsp;transactional&nbsp;application.<br /><br />There are <a href="http://lostechies.com/derekgreer/2007/08/25/interactive-application-architecture/" target="_blank">alternatives</a>, like Facebook's <a href="https://facebook.github.io/flux/docs/overview.html">Flux</a>, but they are usually just refinements of the MVC pattern, although Joëlle&nbsp;Coutaz introduces a hierarchy of MVC-style layers in her <a href="http://iihm.imag.fr/publs/1997/DSVIS97_PACing.pdf">Presentation–Abstraction–Control</a>&nbsp;pattern which is useful for applications that need complex client tiers.<br /><br /></div><div>One thing to bear in mind is that web applications use HTTP which is a <a href="http://en.wikipedia.org/wiki/Stateless_protocol">stateless protocol</a>, so the system must have a Controller that is able to <a href="http://www.ibm.com/developerworks/library/wa-state/">maintain state</a>.<br /><br /></div><h3>Open or closed source software?</h3><div>Your average punter may not care whether they have access to the source code of the software or not, but if you are a software developer, you certainly should care. A mechanic would not buy a car with an engine that was locked up, so why would an I.T. professional use proprietary software? I want to see inside, dammit. I might not know what I am looking at, but I want to poke around anyway (and yeah, I know that Blogger is not open source but I will leave that fight to <a href="http://techrights.org/2014/02/10/stallman-on-google/" target="_blank">Richard Stallman</a>).</div><div><br /></div><div>So goodbye to products from Microsoft, Oracle, Adobe, and IBM, amongst others.</div><div><br /></div><div>Okay, this binary chop between open and closed software means that in terms of the operating system, I am down to Linux, a BSD variant, OpenSolaris, or something less well known like Minix, Darwin, Plan 9 and <a href="http://en.wikipedia.org/wiki/Comparison_of_open-source_operating_systems" target="_blank">the rest</a>.<br /><br /></div><div><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-QgEhMdvK3Z4/VH1jfZe6wUI/AAAAAAAAAx0/gG0dGuA0g7U/s1600/Linus_Windows.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="127" src="https://2.bp.blogspot.com/-QgEhMdvK3Z4/VH1jfZe6wUI/AAAAAAAAAx0/gG0dGuA0g7U/s1600/Linus_Windows.png" width="320" /></a></div><br /></div><div>Let's be sensible and stick to Linux. I am currently using Debian Wheezy but we can argue about <a href="http://www.cyberciti.biz/tips/wp-content/uploads/2007/06/44218-linuxdistrotimeline-7.2.png" target="_blank">the distro</a> later.&nbsp;</div><div><br /></div><h3>Relational or NoSQL?</h3><div>The next binary chop involves the data layer. My raw dataset is already in a highly normalised relational format, so it makes no sense to convert it to one of the <a href="http://martinfowler.com/nosql.html" target="_blank">NoSQL databases</a>. Just import it into a relational database. But which one?&nbsp;</div><div><br /></div><div>The major open source relational databases are MySQL, MariaDB (which was forked from MySQL), and PostgreSQL. I <a href="http://www.zdnet.com/oracle-abandons-commercial-support-for-glassfish-jee-server-7000022945/">don't trust Oracle</a> with the custodianship of open source software, so that eliminates MySQL, and I don't see compelling technical arguments for MariaDB over PostgreSQL, so PostgreSQL it is.&nbsp;</div><div><br /></div><h3>Static or dynamic type-checking? Functional or procedural? Compiled or interpreted?</h3><div>I need a programming language to manipulate the model. The application needs a state engine, mechanisms to provide transactional integrity and role-based access control, so a server-side template engine is not going to cut it. I have to carve code, but what sort of code?<br /><br />Entering into a discussion about the merits and demerits of a programming language is like competing in a <a href="http://www.bbc.com/news/uk-wales-mid-wales-28937459">bog snorkelling</a> championship. There are no winners, just a bunch of cold, wet, exhausted people, covered in mud and weeds.<br /><br />We can nail down some basic requirements though, like readability. Nobody wants to maintain code that looks like it was written by someone with bits of toast stuck in the keyboard, so that excludes Turing tar-pits like&nbsp;<a href="http://www.hevanet.com/cristofd/brainfuck/brainfuck.html" target="_blank">Brainfuck</a>&nbsp;or functional languages like <a href="http://landoflisp.com/wumpus.lisp" target="_blank">Lisp</a>.<br /><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="https://images-blogger-opensocial.googleusercontent.com/gadgets/proxy?url=http%3A%2F%2Fimgs.xkcd.com%2Fcomics%2Flisp_cycles.png&amp;container=blogger&amp;gadget=a&amp;rewriteMime=image%2F*" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="131" size="90%" src="https://imgs.xkcd.com/comics/lisp_cycles.png" style="text-align: center;" target="_blank" width="400" /></a></div><div><br /></div><div><div style="clear: right; float: right; margin-bottom: 1em; margin-left: 1em;"></div>Variable typing is another. I like a variable to be clear about its role in a piece of code, and so do compilers. A language with static types will have fewer surprises at runtime and a compiler can get cracking with its optimisations straightaway, so I decided to go for Java because I am creating a web site, not writing a device driver, and <a href="http://lwn.net/Articles/249460/" target="_blank">C++</a> makes me feel seasick.<br /><br />Java might not be as elegant as&nbsp;<a href="https://www.haskell.org/haskellwiki/Why_Haskell_matters">Haskell</a>&nbsp;and it has its&nbsp;<a href="http://www.paulgraham.com/javacover.html">detractors</a>, but&nbsp;it has a just-in-time compiler, garbage collection, a raft of libraries for reuse, and Java 8 introduces lambda expressions which reduces bulky anonymous inner classes to single expressions. Not too shabby then.<br /><br /></div><div><h3>Bare bones or the full Monty?&nbsp;</h3></div><div>Okay, so now I need a Java application server that runs on Linux. The choices are Jetty, Geronimo, TomEE, GlassFish, Enhydra, Resin, JOnAS,&nbsp;JBoss EAP (now Redhat) or WildFly.<br /><br />But do I really need a full blown application server? I want a bare-bones solution,&nbsp;<a href="http://quoteinvestigator.com/2011/05/13/einstein-simple/">simple, but not too simple</a>, so I decided to stick with Apache Tomcat because it is one of the most widely used application servers and, although it is just a servlet container, it can be beefed up by adding other components of the Java EE stack as required. Well, within reason, unless you want to recreate TomEE on your own.<br /><br />As a bonus the Tomcat API documentation is full of terms like Valve, Filter, Container, Pipeline and Engine which is what you want to hear in a software workshop.<br /><br /><h3>Web frameworks for the JVM</h3></div></div><div>Unfortunately I could not find a cleavage plane to divide up the hardest decision: which Java web development framework to use.<br /><br />Community-driven or standards-driven?&nbsp;Component-based or request-based? Rich responsive user interface or server-side rendering? Cutting-edge or tried-and-tested?&nbsp;</div><br /><div>Matt Raible has done<a href="http://raibledesigns.com/rd/entry/comparing_jvm_web_frameworks_at"> excellent work</a> sketching out the landscape, as <a href="http://zeroturnaround.com/rebellabs/the-curious-coders-java-web-frameworks-comparison-spring-mvc-grails-vaadin-gwt-wicket-play-struts-and-jsf/">have</a>&nbsp;the guys at&nbsp;ZeroTurnaround, so based on their spade work, I see that if this was a Reality TV contest called Survivor JVM 2014, SpringMVC would be leading the pack, with JavaServer Faces hard on its heels. Also in the race are Grails, Vaadin, Google Web Toolkit, Play, and Struts.<br /><br /><div style="margin-left: 1em; margin-right: 1em;"><img height="312" src="https://zeroturnaround.com/wp-content/uploads/2014/06/report-screen.png" width="400" /></div><br />There are no right or wrong decisions at this point, they will all do the job, but I have to choose one.<br /><br /><a href="http://spring.io/guides/gs/serving-web-content/">SpringMVC</a> is a request-based MVC framework so it provides a lot of control of the client-side HTML, CSS and JavaScript, but it does not follow the Java EE standard. It did give J2EE a good kick in the pants though, which was ultimately a good thing for web development in general.<br /><br /><a href="https://grails.org/learn">Grails</a> makes good reuse of Spring and Hibernate but I really don't want to wrap my head around Groovy, even though it is a superset of Java and runs on the JVM.<br /><br /><a href="https://www.playframework.com/documentation/2.3.x/Home">Play</a>&nbsp;looks interesting, and&nbsp;I can see the attraction of convention over configuration, but if I am not using Scala, what are the advantages of abandoning the servlet specification?<br /><br /><a href="http://struts.apache.org/release/2.3.x/docs/home.html">Struts</a> paved the way for other Java frameworks and is still widely used as a consequence, but it has long since been overtaken by the others.<br /><br /><a href="https://vaadin.com/learn">Vaadin</a> uses <a href="http://www.gwtproject.org/overview.html">GWT</a> widgets and they both produce very rich user interfaces. Vaadin is particularly impressive and is from Finland, like&nbsp;gravlax&nbsp;and the reindeer it is named after, but, like <a href="http://www.nytimes.com/1998/11/11/dining/the-minimalist-gravlax-without-fear-a-stunning-dish-just-looks-hard.html">gravlax</a>, it is too rich to eat every day.<br /><br />So that leaves <a href="https://docs.oracle.com/javaee/7/tutorial/jsf-intro.htm">JavaServer Faces</a>.<br /><br />Like all the other frameworks, JSF has its <a href="http://ptrthomas.wordpress.com/2009/05/15/jsf-sucks/">detractors</a>, including&nbsp;<a href="https://www.youtube.com/watch?v=9ei-rbULWoA#t=47m">James Gosling himself</a>, but it provides a Controller with a well documented request-response life-cycle that can manage state, and it has had a new lease on life thanks to component libraries like PrimeFaces.<br /><br /><h3>Changing landscape</h3><div>Having settled on JSF, it is worth noting that the View layer of Java web applications is currently in a <a href="https://weblogs.java.net/blog/editor/archive/2014/03/26/poll-result-future-view-layer-java-ee-applications">state of flux</a>.<br /><br />The Java EE 8 spec&nbsp;<a href="http://arjan-tijms.omnifaces.org/2014/11/jsf-and-mvc-10-comparison-in-code.html">includes</a>&nbsp;an action-based MVC, but server-side web application frameworks are coming under pressure from HTML5 and client-side JavaScript MVC frameworks like <a href="https://angularjs.org/">AngularJS</a>&nbsp;and <a href="http://backbonejs.org/">Backbone</a> that communicate with the server using JSON over REST or WebSocket. In fact, there is a project called <a href="http://www.beyondjava.net/blog/angularfaces-jsf-beyond-ajax/">AngularFaces</a>&nbsp;that tries to combine AngularJS with JSF.&nbsp;</div></div><div><br />The key is to make sure that the web application has a very clean <a href="http://en.wikipedia.org/wiki/Separation_of_concerns">separation of concerns</a>&nbsp;so that if the decision to use JSF gets overtaken by events it can be stripped out without leaving too much damage to the remaining parts of the stack.<br /><br /><a href="http://1.bp.blogspot.com/-JhMbW1u95fo/VIVhc4B6WvI/AAAAAAAAAzU/ZmLaBkqO6W0/s1600/MVC_stack.png" imageanchor="1" style="clear: right; float: right; margin-bottom: 1em; margin-left: 1em;"><img border="0" height="320" src="https://1.bp.blogspot.com/-JhMbW1u95fo/VIVhc4B6WvI/AAAAAAAAAzU/ZmLaBkqO6W0/s1600/MVC_stack.png" width="296" /></a>So the technology stack looks like this: a View consisting of HTML, CSS and JavaScript running in a browser, a Controller consisting of JavaServer Faces in a Tomcat servlet container, and a Model provided by PostgreSQL. The server will run on Linux.<br /><br /></div>